{"meta":{"title":"CountLee's blog","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Yarn--快速、可靠、安全的依赖管理工具。","slug":"Yarn","date":"2018-12-19T02:52:41.000Z","updated":"2019-05-30T10:25:45.025Z","comments":true,"path":"2018/12/19/Yarn/","link":"","permalink":"http://yoursite.com/2018/12/19/Yarn/","excerpt":"","text":"Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。就像我们可以从官方文档了解那样，它的目的是解决这些团队使用 npm 面临的少数问题，即：121.安装的时候无法保证速度/一致性2.安全问题，因为 npm 安装时允许运行代码 Yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化 —— 你同样可以正常获取与发布包。 一、 安装此次安装说明只针对macOS环境 1.1 Homebrew你可以通过 Homebrew 包管理工具 安装 Yarn。 如果你还未安装 Node.js，Homebrew 会自动为你安装。1brew install yarn 如果你是 nvm 或类似工具，你应当避免安装 Node.js ，以便使用 nvm 版本的 Node.js 。1brew install yarn --without-node 1.2 MacPorts你可以通过 MacPorts 安装 Yarn 。 如果你还未安装 Node.js ， MacPorts 会自动为你安装。1sudo port install yarn 1.3 路径设置如果未在 PATH 环境变量中找到 yarn，请按照以下步骤添加 yarn 到 PATH 环境变量中，使其可随处运行。 注意：您的配置文件可能是 `.profile` 、 `.bash_profile` 、 `.bashrc` 、 `.zshrc` 等。 将此项加入您的配置文件： export PATH=&quot;$PATH:/opt/yarn-[version]/bin&quot; （路径可能根据您安装 Yarn 的位置而有差异） 在终端中，执行登录并登出以使更改生效 为了可以全局访问 Yarn 的可执行文件，需要在您的终端中设置 PATH 环境变量。若要执行此操作，请添加 export PATH=&quot;$PATH:yarn global bin&quot; 到您的配置文件中。 1.4 升级 Yarn有新版时，Yarn会给你提示。如需升级 Yarn，仍然可以通过 Homebrew 来升级。1brew upgrade yarn 通过如下命令测试 Yarn 是否安装成功：1yarn --version 二、 使用方法现在 Yarn 已经安装完毕，可以开始使用了。以下是最常用的命令：初始化一个新项目1yarn init 添加依赖包123yarn add [package]yarn add [package]@[version]yarn add [package]@[tag] 将依赖项添加到不同依赖项类别中分别添加到 devDependencies、peerDependencies 和 optionalDependencies 类别中：123yarn add [package] --devyarn add [package] --peeryarn add [package] --optional 升级依赖包123yarn upgrade [package]yarn upgrade [package]@[version]yarn upgrade [package]@[tag] 移除依赖包1yarn remove [package] 安装项目的全部依赖1yarn 或者1yarn install","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"http://yoursite.com/tags/yarn/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"ES6基础","slug":"ES6","date":"2018-12-18T08:07:37.000Z","updated":"2019-05-30T10:25:45.024Z","comments":true,"path":"2018/12/18/ES6/","link":"","permalink":"http://yoursite.com/2018/12/18/ES6/","excerpt":"","text":"一、变量声明let和const我们都是知道在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如: 1234567function aa() &#123; if(bool) &#123; var test = 'hello man' &#125; else &#123; console.log(test) &#125; &#125; 以上的代码实际上是： 12345678910function aa() &#123; var test // 变量提升 if(bool) &#123; test = 'hello man' &#125; else &#123; //此处访问test 值为undefined console.log(test) &#125; //此处访问test 值为undefined &#125; 所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。 接下来ES6主角登场：我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？ 在一个函数内部在一个代码块内部说白了 {}大括号内的代码块即为let 和 const的作用域。 看以下代码： 12345678function aa() &#123; if(bool) &#123; let test = 'hello man' &#125; else &#123; //test 在此处访问不到 console.log(test) &#125; &#125; let的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。 再来说说const。 12const name = 'lux' name = 'joe' //再次赋值此时会报错 说一道面试题 1234567var funcs = [] for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;) &#125; funcs.forEach(function(func) &#123; func() &#125;) 这样的面试题是大家常见，很多同学一看就知道输出 10 十次但是如果我们想依次输出0到9呢？两种解决方法。直接上代码。 123456789101112131415// ES5告诉我们可以利用闭包解决这个问题 var funcs = [] for (var i = 0; i &lt; 10; i++) &#123; func.push((function(value) &#123; return function() &#123; console.log(value) &#125; &#125;(i))) &#125; // es6 for (let i = 0; i &lt; 10; i++) &#123; func.push(function() &#123; console.log(i) &#125;) &#125; 达到相同的效果，es6简洁的解决方案是不是更让你心动！！！ 二、模板字符串es6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。 第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。 123456//es5 var name = 'lux' console.log('hello' + name) //es6 const name = 'lux' console.log(`hello $&#123;name&#125;`) //hello lux 第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号()直接搞定。12345678// es5 var msg = \"Hi \\ man! \" // es6 const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;` 对于字符串es6当然也提供了很多厉害的方法。说几个常用的。1234567// 1.includes：判断是否包含然后直接返回布尔值 let str = 'hahay' console.log(str.includes('y')) // true // 2.repeat: 获取字符串重复n次 let s = 'he' console.log(s.repeat(3)) // 'hehehe' //如果你带入小数, Math.floor(num) 来处理 三、函数函数默认参数在ES5我们给函数定义参数默认值是怎么样？123456function action(num) &#123; num = num || 200 //当传入num时，num为传入的值 //当没传入参数时，num即有了默认值200 return num &#125; 但细心观察的同学们肯定会发现，num传入为0的时候就是false， 此时num = 200 与我们的实际要的效果明显不一样ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。12345function action(num = 200) &#123; console.log(num) &#125; action() //200 action(300) //300 箭头函数ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。箭头函数最直观的三个特点。不需要function关键字来创建函数省略return关键字继承当前上下文的 this 关键字123456//例如： [1,2,3].map( x =&gt; x + 1 )//等同于： [1,2,3].map((function(x)&#123; return x + 1 &#125;).bind(this)) 说个小细节。当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{}；例如:12var people = name =&gt; 'hello' + name //参数name就没有括号 作为参考12345var people = (name, age) =&gt; &#123; const fullName = 'h' + name return fullName &#125; //如果缺少()或者&#123;&#125;就会报错 四、拓展的对象功能对象初始化简写ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如：123456function people(name, age) &#123; return &#123; name: name, age: age &#125;; &#125; 键值对重名，ES6可以简写如下：123456function people(name, age) &#123; return &#123; name, age &#125;; &#125; ES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法：123456const people = &#123; name: 'lux', getName: function() &#123; console.log(this.name) &#125; &#125; ES6通过省略冒号与 function 关键字，将这个语法变得更简洁123456const people = &#123; name: 'lux', getName () &#123; console.log(this.name) &#125; &#125; ES6 对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}1const obj = Object.assign(&#123;&#125;, objA, objB) 五、更方便的数据访问–解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程ES5我们提取对象中的信息形式如下：1234567const people = &#123; name: 'lux', age: 20 &#125; const name = people.name const age = people.age console.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如123456789101112//对象 const people = &#123; name: 'lux', age: 20 &#125; const &#123; name, age &#125; = people console.log(`$&#123;name&#125; --- $&#123;age&#125;`) //数组 const color = ['red', 'blue'] const [first, second] = color console.log(first) //'red' console.log(second) //'blue' 六、Spread Operator 展开运算符ES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。组装对象或者数组123456789//数组 const color = ['red', 'yellow'] const colorful = [...color, 'green', 'pink'] console.log(colorful) //[red, yellow, green, pink] //对象 const alp = &#123; fist: 'a', second: 'b'&#125; const alphabets = &#123; ...alp, third: 'c' &#125; console.log(alphabets) //&#123; \"fist\": \"a\", \"second\": \"b\", \"third\": \"c\"&#125; 有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项12345678910111213const number = [1,2,3,4,5] const [first, ...rest] = number console.log(rest) //2,3,4,5 //对象 const user = &#123; username: 'lux', gender: 'female', age: 19, address: 'peking' &#125; const &#123; username, ...rest &#125; = user console.log(rest) //&#123;\"address\": \"peking\", \"age\": 19, \"gender\": \"female\"&#125; 对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 stage-2 proposal) 当然如果有重复的属性名，右边覆盖左边1234567891011const first = &#123; a: 1, b: 2, c: 6, &#125; const second = &#123; c: 3, d: 4 &#125; const total = &#123; ...first, ...second &#125; console.log(total) // &#123; a: 1, b: 2, c: 3, d: 4 &#125; 七、import 和 exportimport导入模块、export导出模块1234567891011121314//全部导入import people from './example'//有一种特殊情况，即允许你将整个模块当作单一对象进行导入//该模块的所有导出都会作为对象的属性存在import * as example from \"./example.js\"console.log(example.name)console.log(example.age)console.log(example.getName())//导入部分import &#123;name, age&#125; from './example'// 导出默认, 有且只有一个默认export default App// 部分导出export class App extend Component &#123;&#125;; 以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结：123451.当用export default people导出时，就用 import people 导入（不带大括号）2.一个文件里，有且只能有一个export default。但可以有多个export。3.当用export name 时，就用import &#123; name &#125;导入（记得带上大括号）4.当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, &#123; name, age &#125; 5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example 八、Promise在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。说白了就是用同步的方式去写异步代码。发起异步请求1234fetch('/api/todos') .then(res =&gt; res.json()) .then(data =&gt; (&#123; data &#125;)) .catch(err =&gt; (&#123; err &#125;)); 很有意思的一道面试题12345678910111213setTimeout(function() &#123; console.log(1) &#125;, 0); new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3); &#125;).then(function() &#123; console.log(4); &#125;); console.log(5); Excuse me？这是在搞事！当然以上promise的知识点，这个只是冰山一角。需要更多地去学习应用。 九、Generators生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。OK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。1234567891011// 生成器 function *createIterator() &#123; yield 1; yield 2; yield 3; &#125; // 生成器能像正规函数那样被调用，但会返回一个迭代器 let iterator = createIterator(); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 那生成器和迭代器又有什么用处呢？围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的12345678910111213141516function run(taskDef) &#123; //taskDef即一个生成器函数 // 创建迭代器，让它在别处可用 let task = taskDef(); // 启动任务 let result = task.next(); // 递归使用函数来保持对 next() 的调用 function step() &#123; // 如果还有更多要做的 if (!result.done) &#123; result = task.next(); step(); &#125; &#125; // 开始处理过程 step(); &#125; 生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。你不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 yield 来等待异步操作结束。总结ES6的特性远不止于此，但对于我们日常的开发开说。这已经是够够的了。还有很多有意思的方法。比如findIndex…等等。包括用set来完成面试题常客数组去重问题。我和我的小伙伴们都惊呆了!","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Git常用命令","slug":"Git","date":"2018-12-18T06:20:10.000Z","updated":"2019-05-30T10:25:45.025Z","comments":true,"path":"2018/12/18/Git/","link":"","permalink":"http://yoursite.com/2018/12/18/Git/","excerpt":"","text":"一、新建代码库在当前目录新建一个Git代码库 1$ git init 新建一个目录，将其初始化为Git代码库 1$ git init [project-name] 下载一个项目和它的整个代码历史 1$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置 1$ git config --list 编辑Git配置文件 1$ git config -e [--global] 设置提交代码时的用户信息 12$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 三、增加/删除文件添加指定文件到暂存区 1$ git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 1$ git add [dir] 添加当前目录的所有文件到暂存区 1$ git add . 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交 1$ git add -p 删除工作区文件，并且将这次删除放入暂存区 1$ git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 1$ git rm --cached [file] 改名文件，并且将这个改名放入暂存区 1$ git mv [file-original] [file-renamed] 四、代码提交提交暂存区到仓库区 1$ git commit -m [message] 提交暂存区的指定文件到仓库区 1$ git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 1$ git commit -a 提交时显示所有diff信息 1$ git commit -v 使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息 1$ git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 1$ git commit --amend [file1] [file2] ... 五、分支列出所有本地分支 1$ git branch 列出所有远程分支 1$ git branch -r 列出所有本地分支和远程分支 1$ git branch -a 新建一个分支，但依然停留在当前分支 1$ git branch [branch-name] 新建一个分支，并切换到该分支 1$ git checkout -b [branch] 新建一个分支，指向指定commit 1$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 1$ git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区 1$ git checkout [branch-name] 切换到上一个分支 1$ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 1$ git branch --set-upstream [branch] [remote-branch] 并指定分支到当前分支 1$ git merge [branch] 选择一个commit，合并进当前分支 1$ git cherry-pick [commit] 删除分支 1$ git branch -d [branch-name] 删除远程分支 12$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签-tag列出所有tag 1$ git tag 新建一个tag在当前commit 1$ git tag [tag] 新建一个tag在指定commit 1$ git tag [tag] [commit] 删除本地tag 1$ git tag -d [tag] 删除远程tag 1$ git push origin :refs/tags/[tagName] 查看tag信息 1$ git show [tag] 提交指定tag 1$ git push [remote] [tag] 提交所有tag 1$ git push [remote] --tags 新建一个分支，指向某个tag 1$ git checkout -b [branch] [tag] 七、查看信息显示有变更的文件 1$ git status 显示当前分支的版本历史1$ git log 显示commit历史，以及每次commit发生变更的文件1$ git log --stat 搜索提交历史，根据关键词1$ git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行1$ git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件1$ git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名12$ git log --follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff1$ git log -p [file] 显示过去5次提交1$ git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序1$ git shortlog -sn 显示指定文件是什么人在什么时间修改过1$ git blame [file] 显示暂存区和工作区的代码差异1$ git diff 显示暂存区和上一个commit的差异1$ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1$ git diff HEAD 显示两次提交之间的差异1$ git diff [first-branch]...[second-branch] 显示今天你写了多少行代码1$ git diff --shortstat \"@&#123;0 day ago&#125;\" 显示某次提交的元数据和内容变化1$ git show [commit] 显示某次提交发生变化的文件1$ git show --name-only [commit] 显示某次提交时，某个文件的内容1$ git show [commit]:[filename] 显示当前分支的最近几次提交1$ git reflog 从本地master拉取代码更新当前分支：branch 一般为master1$ git rebase [branch] 八、远程同步1$ git remote update --更新远程仓储 下载远程仓库的所有变动1$ git fetch [remote] 显示所有远程仓库1$ git remote -v 显示某个远程仓库的信息1$ git remote show [remote] 增加一个新的远程仓库，并命名1$ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并1$ git pull [remote] [branch] 上传本地指定分支到远程仓库1$ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突1$ git push [remote] --force 推送所有分支到远程仓库1$ git push [remote] --all 九、撤销恢复暂存区的指定文件到工作区1$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区1$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变1$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致1$ git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变1$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致1$ git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变1$ git reset --keep [commit] 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支1$ git revert [commit] 暂时将未提交的变化移除，稍后再移入12$ git stash$ git stash pop","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]}]}